name: Backend CD

# ============================================================
# Ìä∏Î¶¨Í±∞ ÏÑ§Ï†ï: CI ÏõåÌÅ¨ÌîåÎ°úÏö∞ ÏôÑÎ£å ÌõÑ ÏûêÎèô Ïã§Ìñâ
# ============================================================
on:
  workflow_run:
    workflows: ["Backend CI"]
    types:
      - completed
    branches:
      - dev
      - main

permissions:
  contents: read
  actions: read
  id-token: write

# # ============================================================
# # ÎèôÏãúÏÑ± Ï†úÏñ¥: Í∞ôÏùÄ Î∏åÎûúÏπòÏóêÏÑú ÏÉà Ïã§Ìñâ Ïãú Ïù¥Ï†Ñ Ïã§Ìñâ Ï∑®ÏÜå
# # ============================================================
# concurrency:
#   group: cd-${{ github.event.workflow_run.head_sha || github.run_id  }}
#   cancel-in-progress: true

# ============================================================
# ÌôòÍ≤Ω Î≥ÄÏàò ÏÑ§Ï†ï
# ============================================================
env:
  AWS_REGION: ap-northeast-2

jobs:
  # ============================================================
  # Staging ÌôòÍ≤Ω Î∞∞Ìè¨
  # ============================================================
  deploy-staging:
    name: Deploy to Staging
    if: |
      github.event.workflow_run.conclusion == 'success' &&
      github.event.workflow_run.head_branch == 'dev' &&
      github.event.workflow_run.event == 'push'
    runs-on: ubuntu-latest
    environment:
      name: staging
      url: https://staging-api.klosetlab.site
    timeout-minutes: 30

    permissions:
      id-token: write
      contents: read
      actions: read

    steps:
      # ------------------------------------------------------
      # 1. Checkout (Ïä§ÌÅ¨Î¶ΩÌä∏ ÏÇ¨Ïö©ÏùÑ ÏúÑÌï¥)
      # ------------------------------------------------------
      - name: Checkout repository
        uses: actions/checkout@v4
    
      # ------------------------------------------------------
      # 2. Docker Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Îã§Ïö¥Î°úÎìú
      # ------------------------------------------------------
      - name: Download Docker metadata
        uses: actions/download-artifact@v4
        with:
          name: docker-metadata-dev-${{ github.event.workflow_run.head_sha }}
          github-token: ${{ secrets.GITHUB_TOKEN }}
          run-id: ${{ github.event.workflow_run.id }}

      - name: Extract image info
        id: image
        run: |
          if [ -f docker-metadata.json ]; then
            IMAGE_URI=$(cat docker-metadata.json | jq -r '.imageUri')
            IMAGE_TAG=$(cat docker-metadata.json | jq -r '.imageTag')
            VERSION=$(cat docker-metadata.json | jq -r '.version')
            
            echo "image_uri=${IMAGE_URI}" >> $GITHUB_OUTPUT
            echo "image_tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
            echo "version=${VERSION}" >> $GITHUB_OUTPUT
            
            echo "### Docker Image Info" >> $GITHUB_STEP_SUMMARY
            echo "- **Image URI:** \`${IMAGE_URI}\`" >> $GITHUB_STEP_SUMMARY
            echo "- **Image Tag:** \`${IMAGE_TAG}\`" >> $GITHUB_STEP_SUMMARY
            
            cat docker-metadata.json | jq '.'
          else
            echo "::error::Docker metadata not found!"
            exit 1
          fi

      # ------------------------------------------------------
      # 3. AWS OIDC Ïù∏Ï¶ù
      # ------------------------------------------------------
      - name: Configure AWS credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_DEV_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActions-Dev-${{ github.run_id }}

      # ------------------------------------------------------
      # 4. ÌòÑÏû¨ ÌôòÍ≤Ω ÌôïÏù∏
      # ------------------------------------------------------
      - name: Check current environment
        id: current-check
        run: |
          LISTENER_ARN="${{ secrets.DEV_ALB_LISTENER_ARN }}"

          CURRENT_TG_ARN=$(aws elbv2 describe-listeners \
            --listener-arns ${LISTENER_ARN} \
            --query 'Listeners[0].DefaultActions[0].TargetGroupArn' \
            --output text)

          echo "current_tg_arn=${CURRENT_TG_ARN}" >> $GITHUB_OUTPUT

          ALL_ASGS=$(aws autoscaling describe-auto-scaling-groups \
            --query 'AutoScalingGroups[?starts_with(AutoScalingGroupName, `klosetlab-staging-v2-app-`)].AutoScalingGroupName' \
            --output json)

          CURRENT_ASG="none"
          for asg in $(echo "$ALL_ASGS" | jq -r '.[]'); do
            TG_ARNS=$(aws autoscaling describe-auto-scaling-groups \
              --auto-scaling-group-names "$asg" \
              --query 'AutoScalingGroups[0].TargetGroupARNs' \
              --output json)

            if echo "$TG_ARNS" | jq -e --arg tg "$CURRENT_TG_ARN" 'index($tg)' > /dev/null; then
              CURRENT_ASG="$asg"
              break
            fi
          done

          echo "current_asg=${CURRENT_ASG}" >> $GITHUB_OUTPUT

          if [ "$CURRENT_ASG" != "none" ]; then
            DESIRED=$(aws autoscaling describe-auto-scaling-groups \
              --auto-scaling-group-names ${CURRENT_ASG} \
              --query 'AutoScalingGroups[0].DesiredCapacity' \
              --output text)
            MIN=$(aws autoscaling describe-auto-scaling-groups \
              --auto-scaling-group-names ${CURRENT_ASG} \
              --query 'AutoScalingGroups[0].MinSize' \
              --output text)
            MAX=$(aws autoscaling describe-auto-scaling-groups \
              --auto-scaling-group-names ${CURRENT_ASG} \
              --query 'AutoScalingGroups[0].MaxSize' \
              --output text)

            echo "desired=${DESIRED}" >> $GITHUB_OUTPUT
            echo "min=${MIN}" >> $GITHUB_OUTPUT
            echo "max=${MAX}" >> $GITHUB_OUTPUT

            echo "### üìä Current Environment" >> $GITHUB_STEP_SUMMARY
            echo "- **ASG:** \`${CURRENT_ASG}\`" >> $GITHUB_STEP_SUMMARY
            echo "- **Capacity:** ${DESIRED} (min: ${MIN}, max: ${MAX})" >> $GITHUB_STEP_SUMMARY
          else
            echo "desired=1" >> $GITHUB_OUTPUT
            echo "min=1" >> $GITHUB_OUTPUT
            echo "max=2" >> $GITHUB_OUTPUT
            echo "First deployment" >> $GITHUB_STEP_SUMMARY
          fi

      # ------------------------------------------------------
      # 5. User Data ÏÉùÏÑ±
      # ------------------------------------------------------
      - name: Generate User Data script
        id: userdata
        run: |
          chmod +x .github/scripts/generate-userdata.sh
          
          .github/scripts/generate-userdata.sh \
            "staging" \
            "${{ steps.image.outputs.image_uri }}" \
            "${{ env.AWS_REGION }}"
      
      # ------------------------------------------------------
      # 6. Launch Template Î≤ÑÏ†Ñ ÏÉùÏÑ±
      # ------------------------------------------------------
      - name: Create new Launch Template version
        id: new-lt
        run: |
          LT_ID="${{ secrets.DEV_LAUNCH_TEMPLATE_ID }}"
          USER_DATA="${{ steps.userdata.outputs.user_data_base64 }}"
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          
          NEW_LT_VERSION=$(aws ec2 create-launch-template-version \
            --launch-template-id ${LT_ID} \
            --source-version '$Latest' \
            --launch-template-data "{
              \"UserData\": \"${USER_DATA}\",
              \"TagSpecifications\": [{
                \"ResourceType\": \"instance\",
                \"Tags\": [
                  {\"Key\": \"Name\", \"Value\": \"klosetlab-staging-v2-app-${TIMESTAMP}\"},
                  {\"Key\": \"Environment\", \"Value\": \"staging\"},
                  {\"Key\": \"ImageTag\", \"Value\": \"${{ steps.image.outputs.image_tag }}\"},
                  {\"Key\": \"CommitSHA\", \"Value\": \"${{ github.event.workflow_run.head_sha }}\"}
                ]
              }]
            }" \
            --query 'LaunchTemplateVersion.VersionNumber' \
            --output text)
          
          echo "new_lt_version=${NEW_LT_VERSION}" >> $GITHUB_OUTPUT
          echo "‚úÖ Launch Template version ${NEW_LT_VERSION} created"

      # ------------------------------------------------------
      # 7. ASG ÏÉùÏÑ±
      # ------------------------------------------------------
      # - name: Create new ASG
      #   id: new-asg
      #   run: |
      #     TIMESTAMP=$(date +%Y%m%d-%H%M%S)
      #     NEW_ASG_NAME="klosetlab-staging-v2-app-asg-${TIMESTAMP}"
      #     CURRENT_TG_ARN="${{ steps.current-check.outputs.current_tg_arn }}"

      #     if [ -z "$CURRENT_TG_ARN" ] || [ "$CURRENT_TG_ARN" = "None" ]; then
      #       CURRENT_TG_ARN="${{ secrets.DEV_TARGET_GROUP_ARN }}"
      #     fi

      #     aws autoscaling create-auto-scaling-group \
      #       --auto-scaling-group-name ${NEW_ASG_NAME} \
      #       --launch-template "LaunchTemplateId=${{ secrets.DEV_LAUNCH_TEMPLATE_ID }},Version=${{ steps.new-lt.outputs.new_lt_version }}" \
      #       --min-size ${{ steps.current-check.outputs.min }} \
      #       --max-size ${{ steps.current-check.outputs.max }} \
      #       --desired-capacity ${{ steps.current-check.outputs.desired }} \
      #       --target-group-arns ${CURRENT_TG_ARN} \
      #       --vpc-zone-identifier "${{ secrets.DEV_SUBNET_IDS }}" \
      #       --health-check-type EC2 \
      #       --health-check-grace-period 60 \
      #       --tags "Key=Name,Value=klosetlab-staging-v2-app,PropagateAtLaunch=true" \
      #              "Key=Environment,Value=staging,PropagateAtLaunch=true" \
      #              "Key=ImageTag,Value=${{ steps.image.outputs.image_tag }},PropagateAtLaunch=true"

      #     echo "new_asg_name=${NEW_ASG_NAME}" >> $GITHUB_OUTPUT

      #     echo "### üü¢ New ASG Created" >> $GITHUB_STEP_SUMMARY
      #     echo "- **ASG:** \`${NEW_ASG_NAME}\`" >> $GITHUB_STEP_SUMMARY

      - name: Create new ASG
        id: new-asg
        run: |
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          NEW_ASG_NAME="klosetlab-staging-v2-app-asg-${TIMESTAMP}"
          CURRENT_TG_ARN="${{ steps.current-check.outputs.current_tg_arn }}"

          if [ -z "$CURRENT_TG_ARN" ] || [ "$CURRENT_TG_ARN" = "None" ]; then
            CURRENT_TG_ARN="${{ secrets.DEV_TARGET_GROUP_ARN }}"
          fi

          aws autoscaling create-auto-scaling-group \
            --auto-scaling-group-name ${NEW_ASG_NAME} \
            --launch-template "LaunchTemplateId=${{ secrets.DEV_LAUNCH_TEMPLATE_ID }},Version=${{ steps.new-lt.outputs.new_lt_version }}" \
            --min-size ${{ steps.current-check.outputs.min }} \
            --max-size ${{ steps.current-check.outputs.max }} \
            --desired-capacity ${{ steps.current-check.outputs.desired }} \
            --target-group-arns ${CURRENT_TG_ARN} \
            --vpc-zone-identifier "${{ secrets.DEV_SUBNET_IDS }}" \
            --health-check-type ELB \
            --health-check-grace-period 180 \
            --tags "Key=Name,Value=klosetlab-staging-v2-app,PropagateAtLaunch=true" \
                   "Key=Environment,Value=staging,PropagateAtLaunch=true" \
                   "Key=ImageTag,Value=${{ steps.image.outputs.image_tag }},PropagateAtLaunch=true"

          echo "new_asg_name=${NEW_ASG_NAME}" >> $GITHUB_OUTPUT

          echo "### üü¢ New ASG Created" >> $GITHUB_STEP_SUMMARY
          echo "- **ASG:** \`${NEW_ASG_NAME}\`" >> $GITHUB_STEP_SUMMARY

      - name: Wait for new ASG to be ready
        timeout-minutes: 15
        run: |
          NEW_ASG="${{ steps.new-asg.outputs.new_asg_name }}"
          CURRENT_TG_ARN="${{ steps.current-check.outputs.current_tg_arn }}"
          EXPECTED=${{ steps.current-check.outputs.desired }}

          if [ -z "$CURRENT_TG_ARN" ] || [ "$CURRENT_TG_ARN" = "None" ]; then
            CURRENT_TG_ARN="${{ secrets.DEV_TARGET_GROUP_ARN }}"
          fi

          MAX_RETRIES=90
          RETRY_COUNT=0

          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            HEALTHY_INSTANCES=$(aws autoscaling describe-auto-scaling-groups \
              --auto-scaling-group-names ${NEW_ASG} \
              --query 'AutoScalingGroups[0].Instances[?HealthStatus==`Healthy` && LifecycleState==`InService`]' \
              --output json | jq 'length')

            NEW_INSTANCE_IDS=$(aws autoscaling describe-auto-scaling-groups \
              --auto-scaling-group-names ${NEW_ASG} \
              --query 'AutoScalingGroups[0].Instances[?LifecycleState==`InService`].InstanceId' \
              --output json)

            HEALTHY_TARGETS=0
            for instance_id in $(echo "$NEW_INSTANCE_IDS" | jq -r '.[]'); do
              STATE=$(aws elbv2 describe-target-health \
                --target-group-arn ${CURRENT_TG_ARN} \
                --targets Id=${instance_id} \
                --query 'TargetHealthDescriptions[0].TargetHealth.State' \
                --output text 2>/dev/null || echo "unknown")
              if [ "$STATE" = "healthy" ]; then
                HEALTHY_TARGETS=$((HEALTHY_TARGETS + 1))
              fi
            done

            echo "[$((RETRY_COUNT + 1))/$MAX_RETRIES] Healthy: ${HEALTHY_INSTANCES} instances, ${HEALTHY_TARGETS} targets (expected: ${EXPECTED})"

            if [ "$HEALTHY_INSTANCES" -ge "$EXPECTED" ] && [ "$HEALTHY_TARGETS" -ge "$EXPECTED" ]; then
              echo "‚úÖ New ASG is ready!"
              exit 0
            fi

            sleep 10
            RETRY_COUNT=$((RETRY_COUNT + 1))
          done

          echo "‚ùå New ASG failed to become healthy"
          exit 1

      # ------------------------------------------------------
      # 9. ASG Ï†ïÎ¶¨
      # ------------------------------------------------------
      - name: Remove old ASG
        if: success() && steps.current-check.outputs.current_asg != 'none'
        run: |
          OLD_ASG="${{ steps.current-check.outputs.current_asg }}"

          aws autoscaling update-auto-scaling-group \
            --auto-scaling-group-name ${OLD_ASG} \
            --min-size 0 --max-size 0 --desired-capacity 0

          sleep 20

          aws autoscaling delete-auto-scaling-group \
            --auto-scaling-group-name ${OLD_ASG} \
            --force-delete

          echo "‚úÖ Old ASG removed: ${OLD_ASG}"
          echo "### üóëÔ∏è Old ASG Removed" >> $GITHUB_STEP_SUMMARY
          echo "- **Deleted:** \`${OLD_ASG}\`" >> $GITHUB_STEP_SUMMARY

      # ------------------------------------------------------
      # 10. Î∞∞Ìè¨ Ï†ïÎ≥¥ Í∏∞Î°ù
      # ------------------------------------------------------
      - name: Record deployment info
        if: success()
        run: |
          cat > deployment-info.json <<EOF
          {
            "environment": "staging",
            "deployed_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "image_uri": "${{ steps.image.outputs.image_uri }}",
            "image_tag": "${{ steps.image.outputs.image_tag }}",
            "new_asg": "${{ steps.new-asg.outputs.new_asg_name }}",
            "old_asg": "${{ steps.current-check.outputs.current_asg }}",
            "commit_sha": "${{ github.event.workflow_run.head_sha }}"
          }
          EOF
          cat deployment-info.json

      # ------------------------------------------------------
      # 11. Î°§Î∞± (Ïã§Ìå® Ïãú)
      # ------------------------------------------------------
      - name: Rollback on failure
        if: failure() && steps.new-asg.outputs.new_asg_name != ''
        run: |
          NEW_ASG="${{ steps.new-asg.outputs.new_asg_name }}"
          
          echo "=== Rolling back ==="
          
          aws autoscaling update-auto-scaling-group \
            --auto-scaling-group-name ${NEW_ASG} \
            --min-size 0 \
            --max-size 0 \
            --desired-capacity 0 || true
          
          sleep 10
          
          aws autoscaling delete-auto-scaling-group \
            --auto-scaling-group-name ${NEW_ASG} \
            --force-delete || true
          
          echo "‚ö†Ô∏è Rollback completed"

      # ------------------------------------------------------
      # 16. Discord ÏïåÎ¶º
      # ------------------------------------------------------
      - name: Send Discord notification on success
        if: success()
        uses: tsickert/discord-webhook@v5.3.0
        with:
          webhook-url: ${{ secrets.DISCORD_WEBHOOK_URL }}
          username: "Backend CD Bot"
          embed-title: "‚úÖ Staging Î∞∞Ìè¨ ÏÑ±Í≥µ"
          embed-description: |
            **ÌôòÍ≤Ω:** Staging üü¢
            **Ïù¥ÎØ∏ÏßÄ:** `${{ steps.image.outputs.image_tag }}`
            **New ASG:** `${{ steps.new-asg.outputs.new_asg_name }}`
            **Old ASG:** `${{ steps.current-check.outputs.current_asg }}`

            ‚úÖ ÏÉà ASG ÏÉùÏÑ± ‚Üí Í∏∞Ï°¥ ASG ÍµêÏ≤¥ ÏôÑÎ£å!

            [üìã Î°úÍ∑∏](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          embed-color: 3066993
        
      - name: Send Discord notification on failure
        if: failure()
        uses: tsickert/discord-webhook@v5.3.0
        with:
          webhook-url: ${{ secrets.DISCORD_WEBHOOK_URL }}
          username: "Backend CD Bot"
          embed-title: "‚ùå Staging Î∞∞Ìè¨ Ïã§Ìå®"
          embed-description: |
            **ÌôòÍ≤Ω:** Staging üü¢
            **Ïù¥ÎØ∏ÏßÄ:** `${{ steps.image.outputs.image_tag }}`

            ‚ùå Î∞∞Ìè¨ Ïã§Ìå® - Î°§Î∞±Îê®

            [üìã Î°úÍ∑∏](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          embed-color: 15158332

  # ============================================================
  # Production ÌôòÍ≤Ω Î∞∞Ìè¨
  # ============================================================
  deploy-prod:
    name: Deploy to Production
    if: |
      github.event.workflow_run.conclusion == 'success' &&
      github.event.workflow_run.head_branch == 'main' &&
      github.event.workflow_run.event == 'push'
    runs-on: ubuntu-latest
    environment:
      name: production
      url: https://klosetlab.site
    timeout-minutes: 60

    permissions:
      id-token: write
      contents: read
      actions: read

    steps:
      # ------------------------------------------------------
      # 1. Checkout (Ïä§ÌÅ¨Î¶ΩÌä∏ ÏÇ¨Ïö©ÏùÑ ÏúÑÌï¥)
      # ------------------------------------------------------
      - name: Checkout repository
        uses: actions/checkout@v4
    
      # ------------------------------------------------------
      # 2. Docker Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Îã§Ïö¥Î°úÎìú
      # ------------------------------------------------------
      - name: Download Docker metadata
        uses: actions/download-artifact@v4
        with:
          name: docker-metadata-main-${{ github.event.workflow_run.head_sha }}
          github-token: ${{ secrets.GITHUB_TOKEN }}
          run-id: ${{ github.event.workflow_run.id }}

      - name: Extract image info
        id: image
        run: |
          if [ -f docker-metadata.json ]; then
            IMAGE_URI=$(cat docker-metadata.json | jq -r '.imageUri')
            IMAGE_TAG=$(cat docker-metadata.json | jq -r '.imageTag')
            VERSION=$(cat docker-metadata.json | jq -r '.version')
            
            echo "image_uri=${IMAGE_URI}" >> $GITHUB_OUTPUT
            echo "image_tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
            echo "version=${VERSION}" >> $GITHUB_OUTPUT
            
            echo "### Docker Image Info" >> $GITHUB_STEP_SUMMARY
            echo "- **Image URI:** \`${IMAGE_URI}\`" >> $GITHUB_STEP_SUMMARY
            echo "- **Image Tag:** \`${IMAGE_TAG}\`" >> $GITHUB_STEP_SUMMARY
            
            cat docker-metadata.json | jq '.'
          else
            echo "::error::Docker metadata not found!"
            exit 1
          fi

      # ------------------------------------------------------
      # 3. AWS OIDC Ïù∏Ï¶ù
      # ------------------------------------------------------
      - name: Configure AWS credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_PROD_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActions-Prod-${{ github.run_id }}

      # ------------------------------------------------------
      # 4. ÌòÑÏû¨ Blue ÌôòÍ≤Ω ÌôïÏù∏
      # ------------------------------------------------------
      - name: Check Blue environment
        id: blue-check
        run: |
          LISTENER_ARN="${{ secrets.PROD_ALB_LISTENER_ARN }}"
          BLUE_TG_ARN="${{ secrets.PROD_BLUE_TARGET_GROUP_ARN }}"

          CURRENT_TG=$(aws elbv2 describe-listeners \
            --listener-arns ${LISTENER_ARN} \
            --query 'Listeners[0].DefaultActions[0].TargetGroupArn' \
            --output text)

          if [ "$CURRENT_TG" != "$BLUE_TG_ARN" ]; then
            echo "‚ùå Listener is not pointing to Blue TG!"
            echo "Expected: ${BLUE_TG_ARN}"
            echo "Current:  ${CURRENT_TG}"
            echo "Ïù¥Ï†Ñ Î∞∞Ìè¨Í∞Ä Ï†ïÏÉÅ ÏôÑÎ£åÎêòÏßÄ ÏïäÏùÄ ÏÉÅÌÉúÏûÖÎãàÎã§. ÌôïÏù∏ ÌõÑ Ïû¨ÏãúÎèÑÌïòÏÑ∏Ïöî."
            exit 1
          fi
          echo "‚úÖ Listener ‚Üí Blue TG confirmed"

          ALL_ASGS=$(aws autoscaling describe-auto-scaling-groups \
            --query 'AutoScalingGroups[?starts_with(AutoScalingGroupName, `klosetlab-app-`)].AutoScalingGroupName' \
            --output json)

          BLUE_ASG="none"
          for asg in $(echo "$ALL_ASGS" | jq -r '.[]'); do
            TG_ARNS=$(aws autoscaling describe-auto-scaling-groups \
              --auto-scaling-group-names "$asg" \
              --query 'AutoScalingGroups[0].TargetGroupARNs' \
              --output json)

            if echo "$TG_ARNS" | jq -e --arg tg "$BLUE_TG_ARN" 'index($tg)' > /dev/null; then
              BLUE_ASG="$asg"
              break
            fi
          done

          echo "blue_asg=${BLUE_ASG}" >> $GITHUB_OUTPUT

          if [ "$BLUE_ASG" != "none" ]; then
            DESIRED=$(aws autoscaling describe-auto-scaling-groups \
              --auto-scaling-group-names ${BLUE_ASG} \
              --query 'AutoScalingGroups[0].DesiredCapacity' \
              --output text)
            MIN=$(aws autoscaling describe-auto-scaling-groups \
              --auto-scaling-group-names ${BLUE_ASG} \
              --query 'AutoScalingGroups[0].MinSize' \
              --output text)
            MAX=$(aws autoscaling describe-auto-scaling-groups \
              --auto-scaling-group-names ${BLUE_ASG} \
              --query 'AutoScalingGroups[0].MaxSize' \
              --output text)

            echo "blue_desired=${DESIRED}" >> $GITHUB_OUTPUT
            echo "blue_min=${MIN}" >> $GITHUB_OUTPUT
            echo "blue_max=${MAX}" >> $GITHUB_OUTPUT

            echo "### üîµ Blue Environment" >> $GITHUB_STEP_SUMMARY
            echo "- **ASG:** \`${BLUE_ASG}\`" >> $GITHUB_STEP_SUMMARY
            echo "- **Capacity:** ${DESIRED} (min: ${MIN}, max: ${MAX})" >> $GITHUB_STEP_SUMMARY
          else
            echo "blue_desired=1" >> $GITHUB_OUTPUT
            echo "blue_min=1" >> $GITHUB_OUTPUT
            echo "blue_max=2" >> $GITHUB_OUTPUT
            echo "First deployment" >> $GITHUB_STEP_SUMMARY
          fi

      # ------------------------------------------------------
      # 5. User Data ÏÉùÏÑ±
      # ------------------------------------------------------
      - name: Generate User Data
        id: userdata
        run: |
          chmod +x .github/scripts/generate-userdata.sh

          .github/scripts/generate-userdata.sh \
            "prod" \
            "${{ steps.image.outputs.image_uri }}" \
            "${{ env.AWS_REGION }}"
      
      # ------------------------------------------------------
      # 6. Launch Template Î≤ÑÏ†Ñ ÏÉùÏÑ±
      # ------------------------------------------------------
      - name: Create Green Launch Template version
        id: green-lt
        run: |
          LT_ID="${{ secrets.PROD_LAUNCH_TEMPLATE_ID }}"
          USER_DATA="${{ steps.userdata.outputs.user_data_base64 }}"
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          
          GREEN_LT_VERSION=$(aws ec2 create-launch-template-version \
            --launch-template-id ${LT_ID} \
            --source-version '$Latest' \
            --launch-template-data "{
              \"UserData\": \"${USER_DATA}\",
              \"TagSpecifications\": [{
                \"ResourceType\": \"instance\",
                \"Tags\": [
                  {\"Key\": \"Name\", \"Value\": \"klosetlab-app-green-${TIMESTAMP}\"},
                  {\"Key\": \"Environment\", \"Value\": \"prod\"},
                  {\"Key\": \"DeploymentColor\", \"Value\": \"green\"},
                  {\"Key\": \"ImageTag\", \"Value\": \"${{ steps.image.outputs.image_tag }}\"}
                ]
              }]
            }" \
            --query 'LaunchTemplateVersion.VersionNumber' \
            --output text)
          
          echo "green_lt_version=${GREEN_LT_VERSION}" >> $GITHUB_OUTPUT

      # ------------------------------------------------------
      # 7. Green ASG ÏÉùÏÑ±
      # ------------------------------------------------------
      - name: üü¢ Create Green ASG
        id: green-asg
        run: |
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          GREEN_ASG_NAME="klosetlab-app-green-${TIMESTAMP}"
          GREEN_TG_ARN="${{ secrets.PROD_GREEN_TARGET_GROUP_ARN }}"
          
          aws autoscaling create-auto-scaling-group \
            --auto-scaling-group-name ${GREEN_ASG_NAME} \
            --launch-template "LaunchTemplateId=${{ secrets.PROD_LAUNCH_TEMPLATE_ID }},Version=${{ steps.green-lt.outputs.green_lt_version }}" \
            --min-size ${{ steps.blue-check.outputs.blue_min }} \
            --max-size ${{ steps.blue-check.outputs.blue_max }} \
            --desired-capacity ${{ steps.blue-check.outputs.blue_desired }} \
            --target-group-arns ${GREEN_TG_ARN} \
            --vpc-zone-identifier "${{ secrets.PROD_SUBNET_IDS }}" \
            --health-check-type EC2 \
            --health-check-grace-period 180 \
            --tags "Key=Name,Value=klosetlab-app-green,PropagateAtLaunch=true" \
                   "Key=Environment,Value=prod,PropagateAtLaunch=true" \
                   "Key=DeploymentColor,Value=green,PropagateAtLaunch=true"
          
          echo "green_asg_name=${GREEN_ASG_NAME}" >> $GITHUB_OUTPUT
          
          echo "### üü¢ Green ASG" >> $GITHUB_STEP_SUMMARY
          echo "- **ASG:** \`${GREEN_ASG_NAME}\`" >> $GITHUB_STEP_SUMMARY

      # ------------------------------------------------------
      # 8. Green ÌôòÍ≤Ω Ï§ÄÎπÑ ÎåÄÍ∏∞ (Ìó¨Ïä§Ï≤¥ÌÅ¨)
      # ------------------------------------------------------
      - name: Wait for Green environment
        timeout-minutes: 20
        run: |
          GREEN_ASG="${{ steps.green-asg.outputs.green_asg_name }}"
          GREEN_TG_ARN="${{ secrets.PROD_GREEN_TARGET_GROUP_ARN }}"
          EXPECTED=${{ steps.blue-check.outputs.blue_desired }}
          
          MAX_RETRIES=120
          RETRY_COUNT=0
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            HEALTHY_INSTANCES=$(aws autoscaling describe-auto-scaling-groups \
              --auto-scaling-group-names ${GREEN_ASG} \
              --query 'AutoScalingGroups[0].Instances[?HealthStatus==`Healthy` && LifecycleState==`InService`]' \
              --output json | jq 'length')


            echo "[$((RETRY_COUNT + 1))/$MAX_RETRIES] Green: ${HEALTHY_INSTANCES} EC2 InService"
            
            if [ "$HEALTHY_INSTANCES" -ge "$EXPECTED" ]; then
              echo "‚úÖ Green environment ready!"
              exit 0
            fi
            
            sleep 10
            RETRY_COUNT=$((RETRY_COUNT + 1))
          done
          
          echo "‚ùå Green environment failed to become healthy"
          exit 1

      # ------------------------------------------------------
      # 9. Îã®Í≥ÑÏ†Å Ìä∏ÎûòÌîΩ Ï†ÑÌôò ÏãúÏûë
      # ------------------------------------------------------
      - name: Traffic Shift - 10% to Green
        id: shift-10
        run: |
          LISTENER_ARN="${{ secrets.PROD_ALB_LISTENER_ARN }}"
          BLUE_TG_ARN="${{ secrets.PROD_BLUE_TARGET_GROUP_ARN }}"
          GREEN_TG_ARN="${{ secrets.PROD_GREEN_TARGET_GROUP_ARN }}"

          echo "=== Finding /api/* rule ARN ==="

          API_RULE_ARN=$(aws elbv2 describe-rules \
            --listener-arn "$LISTENER_ARN" \
            --query "Rules[?Conditions[?Field=='path-pattern' && contains(Values, '/api/*')]].RuleArn" \
            --output text)

          echo "Rule ARN: $API_RULE_ARN"
          
          echo "=== Shifting 10% traffic to Green ==="
          
          aws elbv2 modify-rule \
            --rule-arn "$API_RULE_ARN" \
            --actions "[
              {
                \"Type\": \"forward\",
                \"ForwardConfig\": {
                  \"TargetGroups\": [
                    {\"TargetGroupArn\": \"${BLUE_TG_ARN}\", \"Weight\": 90},
                    {\"TargetGroupArn\": \"${GREEN_TG_ARN}\", \"Weight\": 10}
                  ]
                }
              }
            ]"
          
          echo "‚úÖ 10% traffic on Green"
          echo "### üîÑ Traffic: Blue 90% / Green 10%" >> $GITHUB_STEP_SUMMARY

      - name: Monitor 10% traffic (10 min)
        run: |
          echo "=== Monitoring Green with 10% traffic ==="

          FAIL_COUNT=0
          
          for i in {1..10}; do
            echo "Monitoring... $i/10 minutes"
            
            # Green TG health Ï≤¥ÌÅ¨
            UNHEALTHY=$(aws elbv2 describe-target-health \
              --target-group-arn ${{ secrets.PROD_GREEN_TARGET_GROUP_ARN }} \
              --query 'TargetHealthDescriptions[?TargetHealth.State==`unhealthy`]' \
              --output json | jq 'length')
            
            if [ "$UNHEALTHY" -gt 0 ]; then
              FAIL_COUNT=$((FAIL_COUNT + 1))
              echo "‚ö†Ô∏è Unhealthy detected ($FAIL_COUNT times)"
            else
              FAIL_COUNT=0
            fi

            if [ "$FAIL_COUNT" -ge 3 ]; then
              echo "‚ùå 3 consecutive unhealthy checks. Failing deployment."
              exit 1
            fi
            
            sleep 60
          done
          
          echo "‚úÖ 10% traffic monitoring passed"

      - name: Traffic Shift - 50% to Green
        run: |
          LISTENER_ARN="${{ secrets.PROD_ALB_LISTENER_ARN }}"
          BLUE_TG_ARN="${{ secrets.PROD_BLUE_TARGET_GROUP_ARN }}"
          GREEN_TG_ARN="${{ secrets.PROD_GREEN_TARGET_GROUP_ARN }}"

          echo "=== Finding /api/* rule ARN ==="

          API_RULE_ARN=$(aws elbv2 describe-rules \
            --listener-arn "$LISTENER_ARN" \
            --query "Rules[?Conditions[?Field=='path-pattern' && contains(Values, '/api/*')]].RuleArn" \
            --output text)

          echo "Rule ARN: $API_RULE_ARN"
          
          echo "=== Shifting 50% traffic to Green ==="
          
          aws elbv2 modify-rule \
            --rule-arn "$API_RULE_ARN" \
            --actions "[
              {
                \"Type\": \"forward\",
                \"ForwardConfig\": {
                  \"TargetGroups\": [
                    {\"TargetGroupArn\": \"${BLUE_TG_ARN}\", \"Weight\": 50},
                    {\"TargetGroupArn\": \"${GREEN_TG_ARN}\", \"Weight\": 50}
                  ]
                }
              }
            ]"
          
          echo "‚úÖ 50% traffic on Green"
          echo "### üîÑ Traffic: Blue 50% / Green 50%" >> $GITHUB_STEP_SUMMARY

      - name: Monitor 50% traffic (15 min)
        run: |
          echo "=== Monitoring Green with 50% traffic ==="
          
          for i in {1..15}; do
            echo "Monitoring... $i/15 minutes"
            
            UNHEALTHY=$(aws elbv2 describe-target-health \
              --target-group-arn ${{ secrets.PROD_GREEN_TARGET_GROUP_ARN }} \
              --query 'TargetHealthDescriptions[?TargetHealth.State==`unhealthy`]' \
              --output json | jq 'length')
            
            if [ "$UNHEALTHY" -gt 0 ]; then
              echo "‚ùå Issues detected!"
              exit 1
            fi
            
            sleep 60
          done
          
          echo "‚úÖ 50% traffic monitoring passed"

      - name: Traffic Shift - 100% to Green
        id: shift-100
        run: |
          LISTENER_ARN="${{ secrets.PROD_ALB_LISTENER_ARN }}"
          GREEN_TG_ARN="${{ secrets.PROD_GREEN_TARGET_GROUP_ARN }}"

          echo "=== Finding /api/* rule ARN ==="

          API_RULE_ARN=$(aws elbv2 describe-rules \
            --listener-arn "$LISTENER_ARN" \
            --query "Rules[?Conditions[?Field=='path-pattern' && contains(Values, '/api/*')]].RuleArn" \
            --output text)

          echo "Rule ARN: $API_RULE_ARN"
          
          echo "=== Shifting 100% traffic to Green ==="
          
          aws elbv2 modify-rule \
            --rule-arn "$API_RULE_ARN" \
            --actions "[
              {
                \"Type\": \"forward\",
                \"ForwardConfig\": {
                  \"TargetGroups\": [
                    {\"TargetGroupArn\": \"${GREEN_TG_ARN}\", \"Weight\": 100}
                  ]
                }
              }
            ]"
          
          echo "‚úÖ 100% traffic on Green"
          echo "### ‚úÖ Traffic: Green 100%" >> $GITHUB_STEP_SUMMARY

      - name: Final monitoring (10 min)
        run: |
          echo "=== Final monitoring on Green ==="
          
          for i in {1..10}; do
            echo "Final check... $i/10 minutes"
            
            UNHEALTHY=$(aws elbv2 describe-target-health \
              --target-group-arn ${{ secrets.PROD_GREEN_TARGET_GROUP_ARN }} \
              --query 'TargetHealthDescriptions[?TargetHealth.State==`unhealthy`]' \
              --output json | jq 'length')
            
            if [ "$UNHEALTHY" -gt 0 ]; then
              echo "‚ö†Ô∏è Issues in final monitoring!"
              exit 1
            fi
            
            sleep 60
          done
          
          echo "‚úÖ Final monitoring passed"

      # -------------------------------------------------------
      # 10. Promote Green ‚Üí Blue
      # -------------------------------------------------------
      - name: Promote Green to Blue
        id: promote
        run: |
          GREEN_ASG="${{ steps.green-asg.outputs.green_asg_name }}"
          BLUE_TG_ARN="${{ secrets.PROD_BLUE_TARGET_GROUP_ARN }}"
          GREEN_TG_ARN="${{ secrets.PROD_GREEN_TARGET_GROUP_ARN }}"
          LISTENER_ARN="${{ secrets.PROD_ALB_LISTENER_ARN }}"
          EXPECTED=${{ steps.blue-check.outputs.blue_desired }}

          echo "=== Promoting Green to Blue ==="

          # 1. Green ASGÎ•º Blue TGÏóê Ïó∞Í≤∞
          aws autoscaling attach-load-balancer-target-groups \
            --auto-scaling-group-name ${GREEN_ASG} \
            --target-group-arns ${BLUE_TG_ARN}

          echo "Waiting for Green instances to register in Blue TG..."
          sleep 30

          # 2. Blue TGÏóêÏÑú healthy ÌôïÏù∏
          for i in {1..12}; do
            HEALTHY_IN_BLUE=$(aws elbv2 describe-target-health \
              --target-group-arn ${BLUE_TG_ARN} \
              --query 'TargetHealthDescriptions[?TargetHealth.State==`healthy`]' \
              --output json | jq 'length')

            echo "[$i/12] Healthy in Blue TG: ${HEALTHY_IN_BLUE}/${EXPECTED}"

            if [ "$HEALTHY_IN_BLUE" -ge "$EXPECTED" ]; then
              echo "‚úÖ Green instances healthy in Blue TG"
              break
            fi

            if [ "$i" -eq 12 ]; then
              echo "‚ùå Green instances not healthy in Blue TG"
              exit 1
            fi

            sleep 10
          done

          # 3. ListenerÎ•º Blue TGÎ°ú Î≥µÍµ¨
          API_RULE_ARN=$(aws elbv2 describe-rules \
            --listener-arn "$LISTENER_ARN" \
            --query "Rules[?Conditions[?Field=='path-pattern' && contains(Values, '/api/*')]].RuleArn" \
            --output text)
          
          aws elbv2 modify-rule \
            --rule-arn "$API_RULE_ARN" \
            --actions "[
              {
                \"Type\": \"forward\",
                \"ForwardConfig\": {
                  \"TargetGroups\": [
                    {\"TargetGroupArn\": \"${BLUE_TG_ARN}\", \"Weight\": 100}
                  ]
                }
              }
            ]"

          # 4. Green TGÏóêÏÑú Ïó∞Í≤∞ Ìï¥Ï†ú
          aws autoscaling detach-load-balancer-target-groups \
            --auto-scaling-group-name ${GREEN_ASG} \
            --target-group-arns ${GREEN_TG_ARN} || true

          echo "‚úÖ Promote complete"
          echo "### üîµ Green ‚Üí Blue ÏäπÍ≤© ÏôÑÎ£å" >> $GITHUB_STEP_SUMMARY
          echo "- **New Blue ASG:** \`${GREEN_ASG}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Listener:** ‚Üí Blue TG" >> $GITHUB_STEP_SUMMARY

      # -------------------------------------------------------
      # 11. Old Blue ASG ÏÇ≠Ï†ú
      # -------------------------------------------------------
      - name: Delete old Blue ASG
        if: success() && steps.blue-check.outputs.blue_asg != 'none'
        run: |
          OLD_BLUE_ASG="${{ steps.blue-check.outputs.blue_asg }}"
          BLUE_TG_ARN="${{ secrets.PROD_BLUE_TARGET_GROUP_ARN }}"
          EXPECTED=${{ steps.blue-check.outputs.blue_desired }}

          echo "=== Deleting old Blue ASG: ${OLD_BLUE_ASG} ==="

          # ÏÇ≠Ï†ú Ï†Ñ Blue TG ÏÉÅÌÉú ÏµúÏ¢Ö ÌôïÏù∏ (ÏÉà ASGÍ∞Ä Ï†ïÏÉÅÏù∏ÏßÄ)
          HEALTHY_IN_BLUE=$(aws elbv2 describe-target-health \
            --target-group-arn ${BLUE_TG_ARN} \
            --query 'TargetHealthDescriptions[?TargetHealth.State==`healthy`]' \
            --output json | jq 'length')

          if [ "$HEALTHY_IN_BLUE" -lt "$EXPECTED" ]; then
            echo "‚ö†Ô∏è Blue TG healthy (${HEALTHY_IN_BLUE}) < expected (${EXPECTED})"
            echo "Old Blue ASG ÏÇ≠Ï†úÎ•º Í±¥ÎÑàÎúÅÎãàÎã§: ${OLD_BLUE_ASG}"
            exit 0
          fi

          aws autoscaling update-auto-scaling-group \
            --auto-scaling-group-name ${OLD_BLUE_ASG} \
            --min-size 0 --max-size 0 --desired-capacity 0

          echo "Waiting for old Blue instances to terminate..."
          sleep 30

          aws autoscaling delete-auto-scaling-group \
            --auto-scaling-group-name ${OLD_BLUE_ASG} \
            --force-delete

          echo "‚úÖ Old Blue ASG deleted: ${OLD_BLUE_ASG}"
          echo "### üóëÔ∏è Old Blue ASG Deleted" >> $GITHUB_STEP_SUMMARY
          echo "- **Deleted:** \`${OLD_BLUE_ASG}\`" >> $GITHUB_STEP_SUMMARY

      # ------------------------------------------------------
      # 12. Î∞∞Ìè¨ Ï†ïÎ≥¥ Í∏∞Î°ù
      # ------------------------------------------------------
      - name: Record deployment info
        if: success()
        run: |
          cat > deployment-info.json <<EOF
          {
            "environment": "production",
            "deployment_strategy": "weighted-blue-green",
            "deployed_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "image_uri": "${{ steps.image.outputs.image_uri }}",
            "image_tag": "${{ steps.image.outputs.image_tag }}",
            "new_asg": "${{ steps.green-asg.outputs.green_asg_name }}",
            "old_blue_asg": "${{ steps.blue-check.outputs.blue_asg }}",
            "traffic_shift": "10% ‚Üí 50% ‚Üí 100%",
            "listener_state": "Blue TG (promoted from Green)"
          }
          EOF
          cat deployment-info.json

      # ------------------------------------------------------
      # 13. Î°§Î∞± (Ïã§Ìå® Ïãú Ï¶âÏãú BlueÎ°ú)
      # ------------------------------------------------------
      - name: Rollback to Blue
        if: failure()
        run: |
          LISTENER_ARN="${{ secrets.PROD_ALB_LISTENER_ARN }}"
          BLUE_TG_ARN="${{ secrets.PROD_BLUE_TARGET_GROUP_ARN }}"
          GREEN_ASG="${{ steps.green-asg.outputs.green_asg_name }}"

          echo "=== Emergency Rollback to Blue ==="

          aws elbv2 modify-listener \
            --listener-arn ${LISTENER_ARN} \
            --default-actions Type=forward,TargetGroupArn=${BLUE_TG_ARN} || true

          echo "‚úÖ Listener reverted to Blue TG"

          if [ -n "${GREEN_ASG}" ]; then
            aws autoscaling update-auto-scaling-group \
              --auto-scaling-group-name ${GREEN_ASG} \
              --min-size 0 --max-size 0 --desired-capacity 0 || true

            sleep 20

            aws autoscaling delete-auto-scaling-group \
              --auto-scaling-group-name ${GREEN_ASG} \
              --force-delete || true

            echo "‚úÖ Green ASG deleted"
          fi

          echo "‚ö†Ô∏è Rollback completed - traffic 100% on Blue"

      # ------------------------------------------------------
      # 14. Discord ÏïåÎ¶º
      # ------------------------------------------------------
      - name: Send Discord notification on success
        if: success()
        uses: tsickert/discord-webhook@v5.3.0
        with:
          webhook-url: ${{ secrets.DISCORD_WEBHOOK_URL }}
          username: "Backend CD Bot"
          embed-title: "‚úÖ Production Î∞∞Ìè¨ ÏÑ±Í≥µ"
          embed-description: |
            **ÌôòÍ≤Ω:** Production üî¥
            **Ï†ÑÎûµ:** Weighted Blue-Green
            **Ïù¥ÎØ∏ÏßÄ:** `${{ steps.image.outputs.image_tag }}`
            **New ASG:** `${{ steps.green-asg.outputs.green_asg_name }}`
            **Old Blue ASG:** `${{ steps.blue-check.outputs.blue_asg }}`

            ‚úÖ Ìä∏ÎûòÌîΩ Ï†ÑÌôò ‚Üí Blue ÏäπÍ≤© ‚Üí Old Blue ÏÇ≠Ï†ú ÏôÑÎ£å!

            [üìã Î°úÍ∑∏](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          embed-color: 3066993

      - name: Send Discord notification on failure
        if: failure()
        uses: tsickert/discord-webhook@v5.3.0
        with:
          webhook-url: ${{ secrets.DISCORD_WEBHOOK_URL }}
          username: "Backend CD Bot"
          embed-title: "‚ùå Production Î∞∞Ìè¨ Ïã§Ìå®"
          embed-description: |
            **ÌôòÍ≤Ω:** Production üî¥
            **Ï†ÑÎûµ:** Weighted Blue-Green
            **Ïù¥ÎØ∏ÏßÄ:** `${{ steps.image.outputs.image_tag }}`
            ‚ùå Î∞∞Ìè¨ Ïã§Ìå® - BlueÎ°ú Ï¶âÏãú Î°§Î∞±Îê®

            [üìã Î°úÍ∑∏](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          embed-color: 15158332